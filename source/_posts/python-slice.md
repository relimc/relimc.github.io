---
title: Python 基础：切片
comments: true
date: 2020-05-18 10:41:03
categories: 
- Python
tags:
- 字符串
- 列表
- 元组
---

切片是通过索引来获取序列片段的技术。常见的序列有字符串、列表、元组等等，通过切片技术我们可以灵活地操作字符串、列表和元组。

<!-- more -->

我们从一个列表入手，来掌握切片相关的语法和用法。

```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

![YrPZa4.jpg](https://s1.ax1x.com/2020/05/15/YrPZa4.jpg)

**切片基本语法如下：[起始索引：结束索引：步长]。**

```python
# 选取偶数
numbers[0:10:2] # [0, 2, 4, 6, 8]
```

上例中，我们从列表中截取了偶数序列。它的截取过程是这样的：从起始索引0开始，每隔2个索引（步长为2）取一个值，直到到达结束索引10时停止截取。

我们可能会有疑问，索引10不是不存在吗？

**切片采取左闭右开的规则，切出来的片段不包括结束索引对应的值。**索引10 处不管是否有值，切片都无法获取该值。

假设我们要取完整的 numbers 列表，我们得这么取：

```python
numbers[0:10:1] # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

假设我们不要列表中的9呢，我们得这么取：

```python
numbers[0:9:1] # [0, 1, 2, 3, 4, 5, 6, 7, 8]
```

我们可以发现，因为切片采取左闭右开的规则，如果我们要取得最大索引对应的值，结束索引就必须得大于最大索引。要获取完整 numbers 列表，我们也可以这么写：

```python
# 结束索引为10或者15影响不大，两者都大于最大索引9
numbers[0:15:1] # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

**当起始索引值为 0 时，起始索引值可以省略。**

```python
numbers[:10:1] # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

**当省略步长时，步长默认为1，步长值不能为0。**

```python
numbers[:10] # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

**当起始索引、结束索引和步长都省略时，相当于获取整个列表**

```python
numbers[::] # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# 或者
numbers[:] # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

**当步长为负值时，切片方向变为从右到左，列表发生翻转**

```python
# 取整个序列
numbers[::-1] # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
# 取不包括0的序列
numbers[9:0:-1] # [9, 8, 7, 6, 5, 4, 3, 2, 1]
# 思考并执行以下语句
numbers[9:-1:-1] # []
```

**切片出来的片段是对序列的浅拷贝。**当序列元素是某个变长元素（如列表），切片片段复制的是该元素的指针，而不是在内存中新建一个空间。

```python
li = [1, 2, 3, 4]
ls = li[::]
 
li == ls # True 两个列表的内容相同
id(li) == id(ls) # False 两个列表不在同一个内存空间

##############################################################
############################################################## 

lo = [1, [1, 1], 2, 3]
lp = lo[:2]

print(lp) #[1, [1, 1]]

lo[1].append(1)

print(lp) # [1, [1, 1, 1]]

print(lo[1] == lp[1]) # True 两个元素的内容相同
print(id(lo[1]) == id(lp[1])) # True 两个元素的内存空间是同一个
```